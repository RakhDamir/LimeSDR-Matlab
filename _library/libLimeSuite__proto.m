%
% Copyright (c) 2019 DamirRakhimov
% Copyright (c) 2017 JiangWei
% Copyright (c) 2015 Nuand LLC
%
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
%
% The above copyright notice and this permission notice shall be included in
% all copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
% THE SOFTWARE.
%

function [methodinfo,structs,enuminfo,ThunkLibName]=libLimeSuite__proto
%libLimeSuite__proto Create structures to define interfaces found in 'LimeSuite.dll'.

%This function was generated by loadlibrary.m parser version  on Wed Dec 26 11:08:55 2019
%perl options:'LimeSuite_Build_Thunk.i -outfile=delete_this_file.m -thunkfile=libLimeSuite_thunk_pcwin64.c -header=LimeSuite_Build_Thunk.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);

arch = computer('arch');
switch arch
    case 'glnxa64'
        libname   = 'libLimeSuite_thunk_glnxa64';
        libsuffix = '.so';
        u64_type = 'ulong';
        pathsep   = ':';
    case 'win64'
        libname   = 'libLimeSuite_thunk_pcwin64';
        libsuffix = '.dll';
        u64_type = 'uint64';
        pathsep   = ';';

    case 'maci64'
        % Additionaly type changes for this may be required for OSX support
        libname   = 'libLimeSuite_thunk_maci64';
        libsuffix = '.dylib';
        u64_type = 'ulong';
        pathsep   = ':';

    otherwise
        error(['Unsupported architecture: ' arch]);
end

search_path = [ '.'; strsplit(path, pathsep)'];
for n = 1:length(search_path)
    to_check = fullfile(search_path{n}, [libname libsuffix]);
    if exist(to_check, 'file')
        %fprintf('Found %s\n', to_check);
        ThunkLibName = to_check;
        break
    else
        %fprintf('%s does not exist.\n', to_check);
    end
end

if ~exist('ThunkLibName', 'var')
    error(['Failed to find ' [libname libsuffix] '. Check path().']);
end

%  int __cdecl LMS_GetDeviceList ( lms_info_str_t * dev_list ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='LMS_GetDeviceList'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int8Ptr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_Open ( lms_device_t ** device , const lms_info_str_t info , void * args ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='LMS_Open'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtrPtr', 'int8Ptr', 'voidPtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_Close ( lms_device_t * device ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='LMS_Close'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_Init ( lms_device_t * device ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='LMS_Init'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetNumChannels ( lms_device_t * device , _Bool dir_tx ); 
fcns.thunkname{fcnNum}='int32voidPtr_BoolThunk';fcns.name{fcnNum}='LMS_GetNumChannels'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool'};fcnNum=fcnNum+1;
%  int __cdecl LMS_EnableChannel ( lms_device_t * device , _Bool dir_tx , size_t chan , _Bool enabled ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type '_BoolThunk'];fcns.name{fcnNum}='LMS_EnableChannel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'bool'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetSampleRate ( lms_device_t * device , float_type rate , size_t oversample ); 
fcns.thunkname{fcnNum}=['int32voidPtrdouble' u64_type 'Thunk'];fcns.name{fcnNum}='LMS_SetSampleRate'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'double', u64_type};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetSampleRate ( lms_device_t * device , _Bool dir_tx , size_t chan , float_type * host_Hz , float_type * rf_Hz ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'voidPtrvoidPtrThunk'];fcns.name{fcnNum}='LMS_GetSampleRate'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'doublePtr', 'doublePtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetSampleRateRange ( lms_device_t * device , _Bool dir_tx , lms_range_t * range ); 
fcns.thunkname{fcnNum}='int32voidPtr_BoolvoidPtrThunk';fcns.name{fcnNum}='LMS_GetSampleRateRange'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', 'lms_range_tPtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetLOFrequency ( lms_device_t * device , _Bool dir_tx , size_t chan , float_type frequency ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'doubleThunk'];fcns.name{fcnNum}='LMS_SetLOFrequency'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'double'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetLOFrequency ( lms_device_t * device , _Bool dir_tx , size_t chan , float_type * frequency ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'voidPtrThunk'];fcns.name{fcnNum}='LMS_GetLOFrequency'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'doublePtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetLOFrequencyRange ( lms_device_t * device , _Bool dir_tx , lms_range_t * range ); 
fcns.thunkname{fcnNum}='int32voidPtr_BoolvoidPtrThunk';fcns.name{fcnNum}='LMS_GetLOFrequencyRange'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', 'lms_range_tPtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetAntennaList ( lms_device_t * dev , _Bool dir_tx , size_t chan , lms_name_t * list ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'voidPtrThunk'];fcns.name{fcnNum}='LMS_GetAntennaList'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'int8Ptr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetAntenna ( lms_device_t * dev , _Bool dir_tx , size_t chan , size_t index ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type '' u64_type 'Thunk'];fcns.name{fcnNum}='LMS_SetAntenna'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, u64_type};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetAntenna ( lms_device_t * dev , _Bool dir_tx , size_t chan ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'Thunk'];fcns.name{fcnNum}='LMS_GetAntenna'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetAntennaBW ( lms_device_t * dev , _Bool dir_tx , size_t chan , size_t index , lms_range_t * range ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type '' u64_type 'voidPtrThunk'];fcns.name{fcnNum}='LMS_GetAntennaBW'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, u64_type, 'lms_range_tPtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetNormalizedGain ( lms_device_t * device , _Bool dir_tx , size_t chan , float_type gain ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'doubleThunk'];fcns.name{fcnNum}='LMS_SetNormalizedGain'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'double'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetGaindB ( lms_device_t * device , _Bool dir_tx , size_t chan , unsigned gain ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'uint32Thunk'];fcns.name{fcnNum}='LMS_SetGaindB'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'uint32'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetNormalizedGain ( lms_device_t * device , _Bool dir_tx , size_t chan , float_type * gain ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'voidPtrThunk'];fcns.name{fcnNum}='LMS_GetNormalizedGain'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'doublePtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetGaindB ( lms_device_t * device , _Bool dir_tx , size_t chan , unsigned * gain ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'voidPtrThunk'];fcns.name{fcnNum}='LMS_GetGaindB'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'uint32Ptr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetLPFBW ( lms_device_t * device , _Bool dir_tx , size_t chan , float_type bandwidth ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'doubleThunk'];fcns.name{fcnNum}='LMS_SetLPFBW'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'double'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetLPFBW ( lms_device_t * device , _Bool dir_tx , size_t chan , float_type * bandwidth ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'voidPtrThunk'];fcns.name{fcnNum}='LMS_GetLPFBW'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'doublePtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetLPFBWRange ( lms_device_t * device , _Bool dir_tx , lms_range_t * range ); 
fcns.thunkname{fcnNum}='int32voidPtr_BoolvoidPtrThunk';fcns.name{fcnNum}='LMS_GetLPFBWRange'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', 'lms_range_tPtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetLPF ( lms_device_t * device , _Bool dir_tx , size_t chan , _Bool enable ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type '_BoolThunk'];fcns.name{fcnNum}='LMS_SetLPF'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'bool'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetGFIRLPF ( lms_device_t * device , _Bool dir_tx , size_t chan , _Bool enabled , float_type bandwidth ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type '_BooldoubleThunk'];fcns.name{fcnNum}='LMS_SetGFIRLPF'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'bool', 'double'};fcnNum=fcnNum+1;
%  int __cdecl LMS_Calibrate ( lms_device_t * device , _Bool dir_tx , size_t chan , double bw , unsigned flags ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'doubleuint32Thunk'];fcns.name{fcnNum}='LMS_Calibrate'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'double', 'uint32'};fcnNum=fcnNum+1;
%  int __cdecl LMS_LoadConfig ( lms_device_t * device , const char * filename ); 
fcns.thunkname{fcnNum}='int32voidPtrcstringThunk';fcns.name{fcnNum}='LMS_LoadConfig'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'cstring'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SaveConfig ( lms_device_t * device , const char * filename ); 
fcns.thunkname{fcnNum}='int32voidPtrcstringThunk';fcns.name{fcnNum}='LMS_SaveConfig'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'cstring'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetTestSignal ( lms_device_t * device , _Bool dir_tx , size_t chan , lms_testsig_t sig , int16_t dc_i , int16_t dc_q ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'lms_testsig_tint16int16Thunk'];fcns.name{fcnNum}='LMS_SetTestSignal'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'lms_testsig_t', 'int16', 'int16'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetTestSignal ( lms_device_t * device , _Bool dir_tx , size_t chan , lms_testsig_t * sig ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'voidPtrThunk'];fcns.name{fcnNum}='LMS_GetTestSignal'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'lms_testsig_tPtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetChipTemperature ( lms_device_t * dev , size_t ind , float_type * temp ); 
fcns.thunkname{fcnNum}=['int32voidPtr' u64_type 'voidPtrThunk'];fcns.name{fcnNum}='LMS_GetChipTemperature'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', u64_type, 'doublePtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetSampleRateDir ( lms_device_t * device , _Bool dir_tx , float_type rate , size_t oversample ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Booldouble' u64_type 'Thunk'];fcns.name{fcnNum}='LMS_SetSampleRateDir'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', 'double', u64_type};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetNCOFrequency ( lms_device_t * device , _Bool dir_tx , size_t chan , const float_type * freq , float_type pho ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'voidPtrdoubleThunk'];fcns.name{fcnNum}='LMS_SetNCOFrequency'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'doublePtr', 'double'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetNCOFrequency ( lms_device_t * device , _Bool dir_tx , size_t chan , float_type * freq , float_type * pho ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'voidPtrvoidPtrThunk'];fcns.name{fcnNum}='LMS_GetNCOFrequency'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'doublePtr', 'doublePtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetNCOPhase ( lms_device_t * device , _Bool dir_tx , size_t chan , const float_type * phases , float_type fcw ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'voidPtrdoubleThunk'];fcns.name{fcnNum}='LMS_SetNCOPhase'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'doublePtr', 'double'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetNCOPhase ( lms_device_t * device , _Bool dir_tx , size_t chan , float_type * phases , float_type * fcw ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'voidPtrvoidPtrThunk'];fcns.name{fcnNum}='LMS_GetNCOPhase'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'doublePtr', 'doublePtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetNCOIndex ( lms_device_t * device , _Bool dir_tx , size_t chan , int index , _Bool downconv ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'int32_BoolThunk'];fcns.name{fcnNum}='LMS_SetNCOIndex'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'int32', 'bool'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetNCOIndex ( lms_device_t * device , _Bool dir_tx , size_t chan ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'Thunk'];fcns.name{fcnNum}='LMS_GetNCOIndex'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetGFIRCoeff ( lms_device_t * device , _Bool dir_tx , size_t chan , lms_gfir_t filt , const float_type * coef , size_t count ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'lms_gfir_tvoidPtr' u64_type 'Thunk'];fcns.name{fcnNum}='LMS_SetGFIRCoeff'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'lms_gfir_t', 'doublePtr', u64_type};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetGFIRCoeff ( lms_device_t * device , _Bool dir_tx , size_t chan , lms_gfir_t filt , float_type * coef ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'lms_gfir_tvoidPtrThunk'];fcns.name{fcnNum}='LMS_GetGFIRCoeff'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'lms_gfir_t', 'doublePtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetGFIR ( lms_device_t * device , _Bool dir_tx , size_t chan , lms_gfir_t filt , _Bool enabled ); 
fcns.thunkname{fcnNum}=['int32voidPtr_Bool' u64_type 'lms_gfir_t_BoolThunk'];fcns.name{fcnNum}='LMS_SetGFIR'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool', u64_type, 'lms_gfir_t', 'bool'};fcnNum=fcnNum+1;
%  int __cdecl LMS_EnableCache ( lms_device_t * dev , _Bool enable ); 
fcns.thunkname{fcnNum}='int32voidPtr_BoolThunk';fcns.name{fcnNum}='LMS_EnableCache'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool'};fcnNum=fcnNum+1;
%  int __cdecl LMS_Reset ( lms_device_t * device ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='LMS_Reset'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_ReadLMSReg ( lms_device_t * device , uint32_t address , uint16_t * val ); 
fcns.thunkname{fcnNum}='int32voidPtruint32voidPtrThunk';fcns.name{fcnNum}='LMS_ReadLMSReg'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint16Ptr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_WriteLMSReg ( lms_device_t * device , uint32_t address , uint16_t val ); 
fcns.thunkname{fcnNum}='int32voidPtruint32uint16Thunk';fcns.name{fcnNum}='LMS_WriteLMSReg'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint16'};fcnNum=fcnNum+1;
%  int __cdecl LMS_ReadParam ( lms_device_t * device , struct LMS7Parameter param , uint16_t * val ); 
fcns.thunkname{fcnNum}='int32voidPtrstructLMS7ParametervoidPtrThunk';fcns.name{fcnNum}='LMS_ReadParam'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'LMS7Parameter', 'uint16Ptr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_WriteParam ( lms_device_t * device , struct LMS7Parameter param , uint16_t val ); 
fcns.thunkname{fcnNum}='int32voidPtrstructLMS7Parameteruint16Thunk';fcns.name{fcnNum}='LMS_WriteParam'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'LMS7Parameter', 'uint16'};fcnNum=fcnNum+1;
%  int __cdecl LMS_ReadFPGAReg ( lms_device_t * device , uint32_t address , uint16_t * val ); 
fcns.thunkname{fcnNum}='int32voidPtruint32voidPtrThunk';fcns.name{fcnNum}='LMS_ReadFPGAReg'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint16Ptr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_WriteFPGAReg ( lms_device_t * device , uint32_t address , uint16_t val ); 
fcns.thunkname{fcnNum}='int32voidPtruint32uint16Thunk';fcns.name{fcnNum}='LMS_WriteFPGAReg'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'uint16'};fcnNum=fcnNum+1;
%  int __cdecl LMS_ReadCustomBoardParam ( lms_device_t * device , uint8_t id , float_type * val , lms_name_t units ); 
fcns.thunkname{fcnNum}='int32voidPtruint8voidPtrvoidPtrThunk';fcns.name{fcnNum}='LMS_ReadCustomBoardParam'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'uint8', 'doublePtr', 'int8Ptr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_WriteCustomBoardParam ( lms_device_t * device , uint8_t id , float_type val , const lms_name_t units ); 
fcns.thunkname{fcnNum}='int32voidPtruint8doublevoidPtrThunk';fcns.name{fcnNum}='LMS_WriteCustomBoardParam'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'uint8', 'double', 'int8Ptr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetClockFreq ( lms_device_t * dev , size_t clk_id , float_type * freq ); 
fcns.thunkname{fcnNum}=['int32voidPtr' u64_type 'voidPtrThunk'];fcns.name{fcnNum}='LMS_GetClockFreq'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', u64_type, 'doublePtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetClockFreq ( lms_device_t * dev , size_t clk_id , float_type freq ); 
fcns.thunkname{fcnNum}=['int32voidPtr' u64_type 'doubleThunk'];fcns.name{fcnNum}='LMS_SetClockFreq'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', u64_type, 'double'};fcnNum=fcnNum+1;
%  int __cdecl LMS_VCTCXOWrite ( lms_device_t * dev , uint16_t val ); 
fcns.thunkname{fcnNum}='int32voidPtruint16Thunk';fcns.name{fcnNum}='LMS_VCTCXOWrite'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'uint16'};fcnNum=fcnNum+1;
%  int __cdecl LMS_VCTCXORead ( lms_device_t * dev , uint16_t * val ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrThunk';fcns.name{fcnNum}='LMS_VCTCXORead'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'uint16Ptr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_Synchronize ( lms_device_t * dev , _Bool toChip ); 
fcns.thunkname{fcnNum}='int32voidPtr_BoolThunk';fcns.name{fcnNum}='LMS_Synchronize'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'bool'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GPIORead ( lms_device_t * dev , uint8_t * buffer , size_t len ); 
fcns.thunkname{fcnNum}=['int32voidPtrvoidPtr' u64_type 'Thunk'];fcns.name{fcnNum}='LMS_GPIORead'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'uint8Ptr', u64_type};fcnNum=fcnNum+1;
%  int __cdecl LMS_GPIOWrite ( lms_device_t * dev , const uint8_t * buffer , size_t len ); 
fcns.thunkname{fcnNum}=['int32voidPtrvoidPtr' u64_type 'Thunk'];fcns.name{fcnNum}='LMS_GPIOWrite'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'uint8Ptr', u64_type};fcnNum=fcnNum+1;
%  int __cdecl LMS_GPIODirRead ( lms_device_t * dev , uint8_t * buffer , size_t len ); 
fcns.thunkname{fcnNum}=['int32voidPtrvoidPtr' u64_type 'Thunk'];fcns.name{fcnNum}='LMS_GPIODirRead'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'uint8Ptr', u64_type};fcnNum=fcnNum+1;
%  int __cdecl LMS_GPIODirWrite ( lms_device_t * dev , const uint8_t * buffer , size_t len ); 
fcns.thunkname{fcnNum}=['int32voidPtrvoidPtr' u64_type 'Thunk'];fcns.name{fcnNum}='LMS_GPIODirWrite'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'uint8Ptr', u64_type};fcnNum=fcnNum+1;
%  int __cdecl LMS_SetupStream ( lms_device_t * device , lms_stream_t * stream ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrThunk';fcns.name{fcnNum}='LMS_SetupStream'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'lms_stream_tPtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_DestroyStream ( lms_device_t * dev , lms_stream_t * stream ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrThunk';fcns.name{fcnNum}='LMS_DestroyStream'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'lms_stream_tPtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_StartStream ( lms_stream_t * stream ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='LMS_StartStream'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'lms_stream_tPtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_StopStream ( lms_stream_t * stream ); 
fcns.thunkname{fcnNum}='int32voidPtrThunk';fcns.name{fcnNum}='LMS_StopStream'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'lms_stream_tPtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_RecvStream ( lms_stream_t * stream , void * samples , size_t sample_count , lms_stream_meta_t * meta , unsigned timeout_ms ); 
fcns.thunkname{fcnNum}=['int32voidPtrvoidPtr' u64_type 'voidPtruint32Thunk'];fcns.name{fcnNum}='LMS_RecvStream'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'lms_stream_tPtr', 'voidPtr', u64_type, 'lms_stream_meta_tPtr', 'uint32'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetStreamStatus ( lms_stream_t * stream , lms_stream_status_t * status ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrThunk';fcns.name{fcnNum}='LMS_GetStreamStatus'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'lms_stream_tPtr', 'lms_stream_status_tPtr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_SendStream ( lms_stream_t * stream , const void * samples , size_t sample_count , const lms_stream_meta_t * meta , unsigned timeout_ms ); 
fcns.thunkname{fcnNum}=['int32voidPtrvoidPtr' u64_type 'voidPtruint32Thunk'];fcns.name{fcnNum}='LMS_SendStream'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'lms_stream_tPtr', 'voidPtr', u64_type, 'lms_stream_meta_tPtr', 'uint32'};fcnNum=fcnNum+1;
%  int __cdecl LMS_UploadWFM ( lms_device_t * device , const void ** samples , uint8_t chCount , size_t sample_count , int format ); 
fcns.thunkname{fcnNum}=['int32voidPtrvoidPtruint8' u64_type 'int32Thunk'];fcns.name{fcnNum}='LMS_UploadWFM'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtrPtr', 'uint8', u64_type, 'int32'};fcnNum=fcnNum+1;
%  int __cdecl LMS_EnableTxWFM ( lms_device_t * device , unsigned chan , _Bool active ); 
fcns.thunkname{fcnNum}='int32voidPtruint32_BoolThunk';fcns.name{fcnNum}='LMS_EnableTxWFM'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'uint32', 'bool'};fcnNum=fcnNum+1;
%  int __cdecl LMS_GetProgramModes ( lms_device_t * device , lms_name_t * list ); 
fcns.thunkname{fcnNum}='int32voidPtrvoidPtrThunk';fcns.name{fcnNum}='LMS_GetProgramModes'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'int8Ptr'};fcnNum=fcnNum+1;
%  int __cdecl LMS_Program ( lms_device_t * device , const char * data , size_t size , const lms_name_t mode , lms_prog_callback_t callback ); 
fcns.thunkname{fcnNum}='int32voidPtrcstring' u64_type 'voidPtrvoidPtrThunk';fcns.name{fcnNum}='LMS_Program'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'cstring', u64_type, 'int8Ptr', 'FcnPtr'};fcnNum=fcnNum+1;
%  const lms_dev_info_t * __cdecl LMS_GetDeviceInfo ( lms_device_t * device ); 
fcns.thunkname{fcnNum}='voidPtrvoidPtrThunk';fcns.name{fcnNum}='LMS_GetDeviceInfo'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='lms_dev_info_tPtr'; fcns.RHS{fcnNum}={'voidPtr'};fcnNum=fcnNum+1;
%  const char * LMS_GetLibraryVersion (); 
fcns.thunkname{fcnNum}='cstringThunk';fcns.name{fcnNum}='LMS_GetLibraryVersion'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='cstring'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  const char * __cdecl LMS_GetLastErrorMessage ( void ); 
fcns.thunkname{fcnNum}='cstringvoidThunk';fcns.name{fcnNum}='LMS_GetLastErrorMessage'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='cstring'; fcns.RHS{fcnNum}=[];fcnNum=fcnNum+1;
%  void LMS_RegisterLogHandler ( LMS_LogHandler handler ); 
fcns.thunkname{fcnNum}='voidvoidPtrThunk';fcns.name{fcnNum}='LMS_RegisterLogHandler'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}=[]; fcns.RHS{fcnNum}={'FcnPtr'};fcnNum=fcnNum+1;
structs.LMS7Parameter.members=struct('address', 'uint16', 'msb', 'uint8', 'lsb', 'uint8', 'defaultValue', 'uint16', 'name', 'cstring', 'tooltip', 'cstring');
structs.lms_range_t.members=struct('min', 'double', 'max', 'double', 'step', 'double');
structs.lms_stream_meta_t.members=struct('timestamp', u64_type, 'waitForTimestamp', 'bool', 'flushPartialPacket', 'bool');
structs.lms_stream_t.members=struct('handle', u64_type, 'isTx', 'bool', 'channel', 'uint32', 'fifoSize', 'uint32', 'throughputVsLatency', 'single', 'error0', 'voidPtr');
structs.lms_stream_status_t.members=struct('active', 'bool', 'fifoFilledCount', 'uint32', 'fifoSize', 'uint32', 'underrun', 'uint32', 'overrun', 'uint32', 'droppedPackets', 'uint32', 'sampleRate', 'double', 'linkRate', 'double', 'timestamp', u64_type);
structs.lms_dev_info_t.members=struct('deviceName', 'int8#32', 'expansionName', 'int8#32', 'firmwareVersion', 'int8#16', 'hardwareVersion', 'int8#16', 'protocolVersion', 'int8#16', 'boardSerialNumber', u64_type, 'gatewareVersion', 'int8#16', 'gatewareTargetBoard', 'int8#32');
enuminfo.lms_testsig_t=struct('LMS_TESTSIG_NONE',0,'LMS_TESTSIG_NCODIV8',1,'LMS_TESTSIG_NCODIV4',2,'LMS_TESTSIG_NCODIV8F',3,'LMS_TESTSIG_NCODIV4F',4,'LMS_TESTSIG_DC',5);
enuminfo.lms_gfir_t=struct('LMS_GFIR1',0,'LMS_GFIR2',1,'LMS_GFIR3',2);
methodinfo=fcns;
